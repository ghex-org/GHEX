#!/bin/bash
set -e

REPO_ROOT=$(git rev-parse --show-toplevel)
SCRIPT_DIR="$REPO_ROOT/scripts"
source "$SCRIPT_DIR/container_clang_format.sh"

# Collect files to format:
# - No args: all tracked C/C++ files.
# - With args: normalize each to repo-root–relative.
files=()
if [ "$#" -eq 0 ]; then
    # Tracked files only
    while IFS= read -r f; do files+=("$f"); done < <(
        git -C "$REPO_ROOT" ls-files | grep -E '\.(cpp|hpp|cc|h|cxx|hxx)$' || true
    )
else
    for arg in "$@"; do
        # If tracked, get repo-relative path directly
        if rel="$(git -C "$REPO_ROOT" ls-files --full-name -- "$arg" 2>/dev/null)"; then
            if [ -n "$rel" ]; then files+=("$rel"); continue; fi
        fi
        # Untracked: resolve absolute, then strip repo root prefix
        dirpart="${arg%/*}"
        basepart="${arg##*/}"
        if [ "$dirpart" = "$arg" ]; then
            # no slash in arg (just a filename)
            dirpart="."
        fi
        if absdir="$(cd "$dirpart" 2>/dev/null && pwd -P)"; then
            abspath="$absdir/$basepart"
            case "$abspath" in
                "$REPO_ROOT"/*)
                    rel="${abspath#"$REPO_ROOT"/}"
                    files+=("$rel")
                    ;;
                *)
                    echo "warning: '$arg' is not inside the repo ($REPO_ROOT) — skipping" >&2
                    ;;
            esac
        else
          echo "warning: cannot resolve '$arg' — skipping" >&2
        fi
    done
fi

if [ "${#files[@]}" -eq 0 ]; then
    echo "No files to format."
    exit 0
fi

for FILE in "${files[@]}"; do
    # shellcheck disable=SC2086
    $OCIRUN run --rm $USER_FLAG \
        -v "$REPO_ROOT":/work -w /work \
        "$IMAGE_TAG" -i --style=file "$FILE"
done

echo "Formatting complete."
